<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.54.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Mutex &middot; lihui7800 个人博客</title>

  
  <link type="text/css" rel="stylesheet" href="https://lihui7800.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://lihui7800.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://lihui7800.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://lihui7800.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="lihui7800 个人博客" />

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://lihui7800.github.io/"><h1>lihui7800 个人博客</h1></a>
      <p class="lead">
       lihui signal blog. 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://lihui7800.github.io/">Home</a> </li>
        <li><a href="/"> Home </a></li><li><a href="/post/"> lihui7800 </a></li><li><a href="/tags/"> Tags </a></li><li><a href="/golang/"> Categories </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Mutex</h1>
  <time datetime=2019-02-27T20:19:57&#43;0800 class="post-date">Wed, Feb 27, 2019</time>
  

<h4 id="1-竞态的出现原因">1,竞态的出现原因</h4>

<blockquote>
<p>竞态的产生是因为多个对象同时访问一个对象的时候就会产生。
最常见的例子是数据库。</p>

<p>在开发中多线程首先面对的问题就是如何竞争资源。</p>
</blockquote>

<p>例子来源于网络,大致应该是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></pre></td>
<td class="lntd">
<pre class="chroma">var a = 0

func run() {
	for i := 0; i &lt; 1000; i++ {
		go add()
	}
	time.Sleep(10 * time.Minute)
	fmt.Println(a)
}

func add() {
	a++
}</pre></td></tr></table>
</div>
</div>
<blockquote>
<p>请允许我使用 ==time.Sleep()== 来让主线程等待结果。其实也可以使用waitgroup来调度1000个协程的。</p>

<p>上面的例子可以得出的结果是不一定，如果1000个协程按照顺序进行处理的话结果应该是1000.</p>
</blockquote>

<h4 id="2-要处理竞态-golang提供了一个库-sync-看名字就知道是和竞态有关系的">2, 要处理竞态，golang提供了一个库，sync 看名字就知道是和竞态有关系的。</h4>

<blockquote>
<p>Mutex 互斥锁
1. 首先看下源码：</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></pre></td>
<td class="lntd">
<pre class="chroma"><span class="kn">package</span> <span class="nx">sync</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;internal/race&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">throw</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// provided by runtime
</span><span class="c1"></span>
<span class="c1">// A Mutex is a mutual exclusion lock.
</span><span class="c1">// The zero value for a Mutex is an unlocked mutex.
</span><span class="c1">//
</span><span class="c1">// A Mutex must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">state</span> <span class="kt">int32</span>
	<span class="nx">sema</span>  <span class="kt">uint32</span>
<span class="p">}</span></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>第一句是 互斥锁就是互相排斥的锁。</p>

<p>第二句是 没有上锁的互斥锁的互斥量是0</p>

<p>第三句是 互斥锁一旦使用将不能被复制</p>

<p>这三句话也告诉了我们使用互斥锁的时候需要注意的几个点。</p>
</blockquote>

<p>。</p>

<h4 id="2-根据官方提供的工具进行处理竞态问题">2,根据官方提供的工具进行处理竞态问题</h4>

<blockquote>
<p>回过头来继续解决刚才的竞态问题。我们产生的竞态其实主要是读取数据，如果不排队的话会产生脏读</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></pre></td>
<td class="lntd">
<pre class="chroma">var (
	a  = 0
	wg = sync.WaitGroup{}
	m  = sync.Mutex{}
)

func Run() {
	for i := 0; i &lt; 1000; i++ {
		wg.Add(1)
		go add()
	}
	wg.Wait()
	fmt.Println(a)
}

func add() {
	m.Lock()
	defer m.Unlock()
	a++
	wg.Done()
}</pre></td></tr></table>
</div>
</div>
<blockquote>
<p>经过Mutex的处理，我们得到的结果一定是1000.因为每次锁释放之后才会进行下一次调用。</p>

<p>切记锁一定要是公共的。不然达不到效果。也不能复制的。</p>

<p>==GOLANG== 的==并发哲学:==</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">Do not communicate through shared memory, but share memory by communication.
不要通过共享内存来通信，而应该通过通信来共享内存</pre></td></tr></table>
</div>
</div>
<p>最后给大家一个思考：还记得sync库的开始吗？下面这句话。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func throw(string) // provided by runtime</pre></td></tr></table>
</div>
</div>
<blockquote>
<p>这句话是干嘛的？实现了什么功能呢？</p>
</blockquote>

</div>


    </main>

    
  </body>
</html>
